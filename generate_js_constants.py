import re
import sys
import pathlib
import unicodedata
import xml.sax as sax
from xml.sax.handler import ContentHandler, LexicalHandler, ErrorHandler

EXPORT_PREFIX = "export "
TYPE_PREFIX = ""
TYPE_SUFFIX = ""
LINE_END = "\n"

if len(sys.argv) != 3:
    print("Error: Incorrect number of arguments!")
    print("Usage: {0} INPUT_XSD OUTPUT_JS".format(sys.argv[0]))
    exit(-1)

input_file_name = sys.argv[1]
output_file_name = sys.argv[2]

print("Input file path: " + input_file_name)
print("Output file path: " + output_file_name)

input_file = open(input_file_name, 'r', encoding="utf8")
output_file = open(output_file_name, 'w')

input_source = sax.xmlreader.InputSource()
input_source.setByteStream(input_file)
input_source.setEncoding("utf8")

camel_case_to_block = re.compile(r"([a-z0-9])([A-Z])")

# WARNING: THIS ISNT A COMMA!!!
evil_comma = ","

class JSGenErrorHandler(ErrorHandler):
    def __init__(self, log_file_name):
        self.log_file = open(log_file_name, 'w')

    def error(e):
        print("ERROR: " + e.getMessage())
        log_file.write("ERROR: " + str(e))
        log_file.write(e)

    def fatalError(e):
        print("FATAL ERROR: " + e.getMessage())
        log_file.write("FATAL_ERROR: " + str(e))
        log_file.write(e)
    
    def warning(e):
        print("WARN: " + e.getMessage())
        log_file.write("WARN: " + str(e))


class JSGeneratorHandler(ContentHandler, LexicalHandler):
    def __init__(self, output_file, in_file_name):
        self.in_type = ""
        self.out = output_file
        self.last_comment = ""
        self.in_file_name = in_file_name
        self.current_type = ""
        self.current_enum_list = []

    def comment(self, content):
        t = content.strip()
        t = t.replace("ACCEPTED", "Accepted").replace("AND ", "And ").replace("OR ", "Or ")
        t = t.replace("/", " ").replace("-","_").replace(evil_comma,"")
        t = ' '.join((word[0].upper() + word[1:] + " ") for word in t.split(' '))
        t = t.replace("+", "").replace(":", " ").replace(" ", "")
        t = re.sub("(\(.*$|\[.*$:|\{.$)", "", t)
        t = camel_case_to_block.sub(r"\1_\2", t).upper()
        self.last_comment = t.replace("ONE_M2_M", "ONEM2M").replace("\\,","_")
    
    def startDocument(self):
        print("Starting document...")

    def handleSchemaStart(self, attrs):
        self.out.write("""\
/**
 * Autogenerated from oneM2M TS-0004 XSD schema: {0}
 * See: https://github.com/ExpandingDev/onem2m_js
 */
""".format(self.in_file_name))
         

    def handleEnumerationStart(self, attr):
        self.current_enum_list.append([self.last_comment, attr.getValue("value")])

    def handleSimpleTypeStart(self, attr):
        print("Starting type: " + attr.getValue("name"))
        self.current_type = attr.getValue("name")

    def startElement(self, name, attr):
        if name == "xs:schema":
            self.handleSchemaStart(attr)
        if name == "xs:simpleType":
            self.handleSimpleTypeStart(attr)
        if name == "xs:enumeration":
            self.handleEnumerationStart(attr)

    def endElement(self, name):
        if name == "xs:schema":
            print("Schema end")
        if name == "xs:simpleType":
            if self.current_type == "eprismProtocolAndAlgID":
                self.out.write("/* NOTE: Skipping eprismProtocolAndAlgID due to messed up XSD file */" + LINE_END + LINE_END)
                self.current_enum_list = []
                return

            self.out.write(EXPORT_PREFIX + "var " + TYPE_PREFIX + self.current_type + TYPE_SUFFIX + " = {" + LINE_END);
            for e in self.current_enum_list[:-1]:
                self.out.write("    " + e[0] + ": " + e[1] + "," + LINE_END)
            e = self.current_enum_list[-1]
            self.out.write("    " + e[0] + ": " + e[1] + LINE_END)
            self.out.write("};" + LINE_END + LINE_END)
            self.current_enum_list = []

error_handler = JSGenErrorHandler(output_file_name + ".error.log")
js_generator_handler = JSGeneratorHandler(output_file, input_file_name)

parser = sax.make_parser()
parser.setContentHandler(js_generator_handler)
parser.setErrorHandler(error_handler)
parser.setProperty(sax.handler.property_lexical_handler, js_generator_handler)

parser.parse(input_source)
